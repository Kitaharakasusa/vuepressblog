# Dynamic and Public Auditing with Fair Arbitration for Cloud Data

## 背景

### 一些概念：

CSP: cloud service providers

POR： proofs of retrievability(可回收性)

PDP: provable data possession  可证明的数据持有

TPA: third party auditor

耐碰撞哈希：

双向映射: 一个双向线性映射就是一个 映射$e$ : $G_1*G_2→G_T $ 其中 G1和G2是两个 Gap Diffie-Hellman(GDH) group

### 将数据放在云上面临的新的安全威胁：

1. 尽管服务商提供了强大的安全机制，远程数据仍然面临着网络攻击，硬件损坏，管理错误等

   2.服务商可能回回收一些很少访问或者从未访问的数据，隐藏数据丢失等可能造成声誉影响的问题

用户不再拥有自己的数据，失去了对数据的直接控制，直接使用hash或者encryption等来保证数据完整性和安全性可能导致很多漏洞。另外，下载所有数据并进行检查基本是不可能的，特别是对于大型文件。 虽然在存储安全系统中广泛使用消息验证码（MAC）或基于签名的机制， 但不适用于外包数据的完整性的检查，因为这些方法只能验证检索到的数据的不起作用（例如存档的数据）

### 数据审计计划：

使用户能够在不下载数据的情况下 验证数据的完整性

被称为  blockless 验证

在审计计划下， 用户和CSP周期性的一起通过审计协议去检查数据正确性，方法是去验证CSP算出来的 完整性证明 

这样 用户就能通过自己的验证的结果，而不是服务商告诉你的结果知道数据的完整性，所以可行度提高了很多

   早期的审计计划 需要CSP访问整个的文件去进行完整性检查，从而生成确定的证明。 这样的方法在执行检查的时候会耗费大量的服务器资源， 对于非常大的文件来说，这种方法缺乏效率和可执行性

   有一些审计计划提供了私有验证，只有拥有私有秘钥才能进行审计任务，这样可能会超过数据持有者的计算能力，然后是公有审计，公有审计允许任何有公钥的人去执行审计，这样就可以做到任务的下放，TPA可以代替数据所有者执行完整性检查，并如实的报告结果

  PDP 和POR 只能检查静态数据，存在的一些动态审计方案也无法很好的支持动态

### 审计计划的三个最重要的特征

1、概率证明 2.公有验证 3. 动态数据支持

动态数据验证的难点：

现有的审计计划将block 的index i 作为标签进行计算，当我们插入或删除的时候，索引结构会发生改变，块的标签就会重新进行计算， 这样的计算花费太高了。

我们通过区分标记索引(用于标记计算)和块索引(指示块位置)来解决这个问题，并依赖一个索引切换器来保持它们之间的映射。在每次更新操作时，我们为操作块分配一个新的标记索引，并更新标记索引和块索引之间的映射。这种块索引和标记索引之间的间接性层加强了块的认证，同时避免了在操作位置之后块的重新计算。从而大大提高了数据动态处理的效率

以往的研究都假设安全模型中的数据所有者是诚实的，事实上，不仅仅是云，云用户也有欺诈行为的动机，恶意数据所有者会为了赔偿故意声称数据被损坏了，不可靠的CSP可能会删除很少访问的数据。用签名交换的思想，以保证元数据的正确性和协议的公平性，并将高效的数据动态支持和公平的争端仲裁结合到一个单一的审计方案中

   为了解决审计的公平问题，我们采纳了一种第三方仲裁进入我们的模型，这个第三方是被数据所有者和CSP共同信任的。

由于TPA可以被看作是数据所有者的委托方，并且不一定受到CSP的信任，所以我们将审计人员和仲裁人员的角色进行了区分。此外，我们采用了签名交换的思想，以确保元数据的正确性，并提供纠纷仲裁，其中任何有关审计或数据更新的冲突都可以公平仲裁。

### 什么是签名交换：



block的tag是根据block的index和block的内容生成的 

tag计算公式 $\left.\sigma_{i}=\left(H(i) \cdot u^{m_{i}}\right)^{x}\right)$所以block $m_i$和 tag 是一一对应的

tag是被用户的私有key签名过的， 由于安全签名方案的不可伪造性，它不能被伪造

要启动审计，审计人员将对随机选择的一组块生成一个质询, CSP首先要计算证明proof $π =(μ,σ)$  $μ$是从被请求的block计算来的, $σ$是从 标签计算来的, 由于动态可验证标签的聚集性, 一个数据块和它的标签之间的一一对应也保持在$μ$ 和 $σ$ 之间, 验证算法通过验证$σ$ 和$μ$的一一对应关系 来证明proof的合法性, 也就是说, 他们必须满足满足双向线性映射

如果我们只是简单的计算tag $\sigma_{i}=\left(u^{m_{i}}\right)^{x}$ , 那么服务器可以通过没有被设计的block去计算proof,  如果下标没有嵌入到block的标签中, 验证算法主要确认$\left(u^{m_{i}}\right)^{x}$ 和$m_i$ , 因此任意block和他们的标签都能通过验证, 只要他们本身是完整的. 在这种情况下, 将H(I)嵌入到计算服务来验证block, 然而,由于下标嵌入, 当一个block被插入或者删除,所有block的下标都会改变, 那么tag就要重新计算, 会带来非常大的内存开销

解决这个问题

通过index交换器, 维护block下标和 tag下标之间的映射关系

tag下标只是用来计算tag, block的下标用来只是数据block的逻辑位置. 



![](https://raw.githubusercontent.com/Kitaharakasusa/img/master/20191015152509.png)

 

非对称加密 举个例子  ssh

## 审查计划流程描述:

- KeyGen  客户端

  通过从大素数实数集里面取一个$α$ 得到私钥sk 和公钥pk=(v,w, g,u)

- TagGen  客户端

  一个文件F = {m1,m2, .... mn}组成, 每一块都是相同的大小, 对于每一块$m_i$ , 通过标签计算公式$σ_i = \left(H\left(t_{i}\right) \cdot u^{m_{i}}\right)^{\alpha}$ 其中 ti 是指块的标签下标 tag 集合$\Phi=\left\{\sigma_{i}\right\}_{1 \leq i \leq n}$ , 刚开始的时候, 标签的下标和块的下标是一样的1, 2...n,   然后数据所有者在索引交换器上进行签名, 然后将$\left\{F,Φ, Sig_c\right\}$ 发送给CSP,并且把公钥pk发送给TPAR, 这时候数据所有者会删除本地副本{F, Φ} 但是会保存索引交换器Ω

- Commitment  云端

  这个过程是为了阻止一些带有恶意的数据所有者,在最开始就生成不正确的标签,  这样之后就可以诬告 云服务提供商了.  云根据算法**ProofGen**，从接收到的所有块和标签中生成确定性的proof，并通过算法**ProofVerify**验证验证其有效性。如果验证成功， 云可以确保从接收块计算出的所有标记都是正确的 , 之后, CSP在标签交换器上签名并发送给客户端. 之后 客户端确认签名的正确性, 如果成功, 就保存下来, 否则client会联系TPAR做仲裁

- ProofGen 云端

  为了审核云上数据的完整性,公共的auditor随机挑选了一组块索引$I=\left\{s_{1}, s_{2}, \ldots, s_{c}\right\} \subseteq\{1,2, \ldots, n\}$, $I$是被请求块的索引, 然后auditor发送一个$chal ={(i, v_i)} i∈I$ 到服务器,其中$v_i$属于$Z_p$ 是一个用来计算proof的随机参数.

  

  当接收到审计挑战 $chal = \left\{\left(i, v_{i}\right)\right\}_{i \in I}$  服务器会计算 $\mu=\sum_{i \in I} v_{i} \cdot m_{i}$ 和 $\sigma=\prod_{i \in I} \sigma_{i}^{v_{i}}$ 作为完整性证明. $μ$  表示请求块的线性组合 $σ$ 表示 表示相应标记的聚合签名 , 最终, 服务器发送一个$π = (μ, σ)$ 给auditor做验证

- ProofVerify 审查人员

  当收到完整性证明proof π的时候, verifier 首先将每一个块的索引 $i$ 转换成标签索引 $t_i$ , 用索引交换器得到 $chal'=  \left\{(t_i, vi)\right\}_\left\{i \in\ I\right\} $    之后, verifier通过双向线性映射公式来判断proof的正确性
  $$
  e(\sigma, g) \stackrel{?}{=} e\left(\left(\prod_{i \in I} H\left(t_{i}\right)^{v_{i}}\right) \cdot u^{\mu}, v\right)
  $$
  输出为TRUE和FALSE

- Update 云端

  用户通过执行以下操作之一来更新第k个块 

  - Modification 

    用户将第k块 $m_k$ 修改成 $m'_k$ 首先先分配一个未使用过的 标记 索引$t'_k$ , 然后计算新的标签 $\sigma_{k}^{\prime}=\left(H\left(t_{k}^{\prime}\right) \cdot u^{m_{k}^{\prime}}\right)^{\alpha}$ 然后用户将所以交换器更新到 $Ω'$ , 并发送一个更新请求 $u p_{-} r e q=\left\{s e q, O(M), t, t_{k}^{\prime}, m_{k}^{\prime}, \sigma_{k}^{\prime}, Q^{\prime}, \widehat{Q}^{\prime}, \operatorname{Sig}_{s k_{c}}\left(s e q, \Omega^{\prime}\right)\right\}$ 到服务器, $m'_k$ 和$σ'_k$ 表示被修改的块和新的标签,  $O(M)$ 表示修改, k 和 $t'_k$ 表示快索引和新的标签索引,  $Ω'$ 表示更新过的标签交换器, $Q' = \left\{\left(i, v_{i}\right)\right\}_{i \in I \cap k \in I}$ 是一个小的challenge集合, 其中包括了块$m'_k$ 

  - Insertion

    用户在第k个位置插入一个块$m'_k$ , 计算$m'_k$ 的tag $\sigma_{k}^{\prime}=\left(H\left(t_{k}^{\prime}\right) \cdot u^{m_{k}^{\prime}}\right)^{\alpha}$ , 只有用户会更新索引交换器, 之后发送一个更新请求给发服务器, $up\_req = \left\{\operatorname{seq}, O(I), k, t_{k}^{\prime}, m_{k}^{\prime}, \sigma_{k}^{\prime}, Q^{\prime}, \operatorname{Sig}_{sk_c}\left(\operatorname{seq}, \Omega^{\prime}\right)\right\}$ 其他地方没什么变动, 主要是O(I)表示的是 插入

  - Deletion

    用户删除在k出的block, 更新索引交换器, 之后发送更新请求 $\left\{\operatorname{seq}, O(D), k, t_{k}^{\prime}, m_{k}^{\prime}, \sigma_{k}^{\prime}, Q^{\prime}, \operatorname{Sigsk}_{s c}\left(\operatorname{seq}, \Omega^{\prime}\right)\right\}$ 其中O(D)表示是删除的请求

  当收到 更改和插入的请求up_req, CSP 会通过 $e\left(\sigma_{k}^{\prime}, g\right) \stackrel{?}{=} e\left(H\left(t_{k}^{\prime}\right) \cdot u^{m_{k}^{\prime}}, v\right)$ 来验证 $m'_k$ 和 $σ'_k$ 的正确性, 如果验证成功, 之后CSP会验证从客户端发来的 $\operatorname{Sig}_{s k_{c}}\left(s e q, \Omega^{\prime}\right)$  的正确性 , 如果 都对了, CSP 就会执行替换操作. 用新的$m'_k$ 和 标签 $σ'_k$ 替换久的mk和σ, 对于 插入操作, 回见新的$m'_k$ 和tag放入到F和Φ中. 块的删除操作只要通过签名验证, 成功了就删除. 最终 CSP 会计算签名 $\operatorname{Sig}_{s k_{s}}\left(s e q, \Omega^{\prime}\right)$ , 根据$Q'$ 计算完整性证明  $\pi^{\prime}=\left(\mu^{\prime}, \sigma^{\prime}\right)$ 然后发送$\left(\mu^{\prime}, \sigma^{\prime}, \operatorname{Sig}_{s k_{s}}\left(\operatorname{seq}, \Omega^{\prime}\right)\right)$ 给用户(auditor)做更新确认

- UpdateVertitfy  auditor

  接收到了请求$\left(\mu^{\prime}, \sigma^{\prime}, \operatorname{Sig}_{s k_{s}}\left(\operatorname{seq}, \Omega^{\prime}\right)\right)$ 后 , 通过双向线性映射先验证proof准确与否, 之后验证签名的正确与否, 要是都成功了, 用户就能相信CSP 已经更新了它的数据, 之后将CSP的签名保留下来



这个数据更新的协议

- Dicussion 

  我们假设一个有很多reader和一个writer的场景, 就是说, 只有数据所有者才能够更新数据, 而用户重油读的权利,在这个场景下,  多个更新操作要用串起来执行, 包括苏联因交换器的存储, 但是, 如果在客户端使用并行化技术优化标签生成和证书证明, 那么标签交换器的使用就会成为心梗平静,  一种解决的方式是在多个用户之间复制索引交换器, 由于索引交换器的正确性  会影响审计结果，所以应该保证这些副本之间的强一致性[20]。我们把这种优化方案的实现作为一个重要的未来扩展，它可以结合到一个安全的云存储系统的设计中，以更稳健和有效地处理大规模数据。 

## 争议冲裁

### 4.1总览

在先前的假设中,我们指出在云环境下, client和CSP都用欺骗的动机, 在我们的方案中, 索引交换器是被auditor用来获取被请求的块的 proof 验证的. 因此proof验证的准确性依赖于索引交换器的正确性. 然而,  正如我们之前指出的，在云环境中，客户端和CSP都有作弊的动机。在我们的方案中，审核员使用索引切换器在证明验证阶段获取请求块的标签索引，因此验证结果依赖于索引切换器的正确性。但是，索引切换器的生成和更新仅由数据所有者执行，这可能会给不诚实的所有者带来错误地指控诚实CSP的机会。从这个意义上讲，我们必须提供某种机制来确保索引切换器的正确性，并进一步确保可能进行仲裁的公平性，以便任何一方都可以在不被发现的情况下陷害另一方。

一种简单的方法是让仲裁程序（TPAR）保留索引切换器的副本。由于索引切换器的更改是由动态操作引起的，因此客户端可以为每个更新操作向TPAR发送必要的更新信息（即操作类型，操作位置，新标签索引）。有了这些信息，仲裁员可以重新构造索引切换器的最新版本，其正确性决定了以后仲裁的有效性。但是，这样的解决方案在仲裁器端消耗了$O(n)$存储空间，并且需要仲裁器参与每个更新操作。理想情况下，我们希望TPAR仅扮演仅参与争端解决的仲裁员的角色，并保持状态信息（即客户端和CSP的公共密钥）的恒定存储。

作为替代，我们采用文献[12]中的签名交换思想来确保索引切换器的正确性。
具体来说，我们依靠双方在每次动态操作时在最新的索引切换器上交换其签名。为了抵抗重放攻击，将指示更新时间的序列号嵌入签名中。

一个基本事实是，当客户端最初将其数据上传到云时，云需要运行该承诺以检查外包块及其标签的有效性，然后交换其在初始索引切换器上的签名。如果此初始签名交换失败，则客户端将不会假设其数据已成功上传。另一方面，初始标签索引序列与块索引序列相同，即索引切换器可以表示为$\{(i, i)\}_{1 \leq i \leq n}$；我Þ因此，根据我们的设计，签名交换的这一步骤可以轻松完成，因为索引切换器的初始内容对双方都是公开的，这是以后进行签名交换的基础。从这个意义上讲，我们的仲裁不需要在[12]中存在公平的签名交换协议。此外, 因为索引切换器的更改是由数据更新操作造成的, 只要在每次更新的时候将$\left(\text { i.e., } o p, k, t_{k}^{\prime}\right.$ 等信息发送到CSP, CSP就可以重新构建最新的索引切换器, 这使得CSP可以检查客户端的签名 并生成它在更新的索引切换器上的签名

现在，在每次数据动态操作时，除了验证更新的块和标签之外，CSP还将在更新的索引切换器上检查客户端的签名。如果成功，则CSP将其在更新的索引切换器上的签名发送到客户端进行存储。然后，对于每次成功的更新，每一方都会在更新的索引切换器上保留另一方的签名。这种签名交换意味着双方已经就新的元数据达成了协议，这对于以后的争议解决是必要的。此外，签名是在序列号seq和索引切换器$Ω$的连接上生成的，其中seq是单调递增的整数，每次递增一个。

通常，争执可能是由于对proof（包括更新请求中的更新块$m'_k$ 及其标签$σ'_k$ ）或索引切换器上交换的签名的不同意见引起的。根据发生争议的时间，我们将仲裁时机分为三种情况。

- Case1: 当审核员在审核期间声称证据验证失败时，就会发生争议
- Case2: 当CSP收到来自客户端的无效更新请求up_req时，就会发生争议
- Case3: 当客户端从CSP收到对up_req的无效响应时，就会发生争执

情况1仅涉及 证明 验证的分歧，它发生在先前成功更新之后，在此之前已就索引切换器达成协议。尽管情况2和情况3发生在本轮更新和签名交换完成之前，所以TPAR应该参与协议以对争端进行仲裁并帮助完成更新和签名交换。



### 4.2完整性证明仲裁

让$\operatorname{Sig}_{c}=\operatorname{Sig}_{s k_{c}}(\operatorname{se} q, \Omega)$和$\operatorname{Sig}_{s}=\operatorname{Sig}_{s k_{s}}(\operatorname{seq}, \Omega)$表示上次成功更新中索引切换器上的客户端和CSP签名，其中seq表示最新的序列号。成功的签名交换完成后，客户端将具有服务器的签名Sigs，而服务器将具有客户端的签名Sigc。在仲裁过程中，seqc和seqs表示客户端发送的序列号，CSP表示$Ω_c$和$Ω_s$分别表示客户端发送的索引切换器。我们假设双方的公钥都在某个受信任的PKI中，因此另一方（包括TPAR）可以轻松获取它。在整个协议中，我们假定在第三方之间传输的消息都在经过身份验证的安全通道中。

我们首先描述案例1的仲裁协议，其中争议仅涉及证据争议。当客户在审计过程中发现证据验证失败时，他会与TPAR联系以发起仲裁。由于验证证明的有效性需要访问索引切换器以获取质询块的标签索引，并且验证签名也需要索引切换器，因此每一方都有必要向TPAR发送他保存的最新索引切换器以及签名（在另一方签名的索引切换器上）。仲裁协议如下进行

1. TPAR想客户端请求 $\left\{s e q_{c}, \Omega_{c}, S i g_{s}\right\}$ 。然后，他检查CSP的签名$S i g_{s}$。如果无效，TPAR可能会惩罚客户行为不当；否则，TPAR继续进行.
2. TPAR想CSP请求$\left\{\operatorname{se} q_{s}, \Omega_{s}, S i g_{c}\right\}$;。然后，他检查客户端的签名$Sig_c$。如果签名验证不正确，则TPAR可能会惩罚CSP行为不当；否则，TPAR继续进行。
3. 如果为$seq_c = seq_s$ ，则TPAR向客户端请求导致对证据验证产生争议的质询集Q，并将其重新传输给CSP以运行审核方案。CSP根据ProofGen计算证明，并将其返回给TPAR进行验证。TPAR使用已验证的索引切换器根据ProofVerify检查证明
4. 如果seqc和seqs不匹配。TPAR可以确保序列号较小的一方正在执行重播攻击，他可能会惩罚作弊方。具体来说，如果seqc> seqs，则客户端通过重播来自CSP的旧签名来作弊；如果seqs> seqc，则CSP通过重播客户端的旧签名来作弊。



该协议的安全性依赖于用于对索引切换器进行签名的签名方案的安全性，也就是说，每一方伪造由另一方的私钥签名的签名的可能性均很小。因此，在协议中应防止恶意方发起的重播攻击。由于我们在每次更新的交换签名中都包含一个序列号，因此我们可以通过序列号匹配来检查是否发起了重播攻击。如果两个签名都正确验证并且它们的序列号匹配（seqc = seqs），则我们有$Ω_c = Ω_s$。由于在(0, $Ω_0$)上进行了初始签名交换；在TagGen和承诺中的中，在证明验证发生冲突之前，至少要进行一轮成功的签名交换。



### 4.3动态更新的仲裁

情况2和情况3涉及当前更新周期中签名交换的失败，因此TPAR有必要帮助完成更新和签名交换。为此，应验证上一轮中成功交换的签名以继续进行本轮

协议的前两步和仲裁协议的完整性证明是一样的. TPAR向客户端请求 $\left\{\operatorname{seq}_{c}, \Omega_{c}, \operatorname{Sig}_{s}\right\}$ , 向CSP请求$\left\{s e q_{s}, \Omega_{s}, S i g_{c}\right\}$ 如果TPAR发现了任何无效的前ing, 它会对返回无效签名的一方进行惩罚, 根据对于$seq_c$ 和$seq_s$ 的比较, 我们将协议分为两种情况

#### 序列号相等(seqc=seqs)

1. TPAR向客户端请求记录$\left\{seq_c +1,o p, k, t_{k}^{\prime}, m_{k}^{\prime}, \sigma_{k}^{\prime}, Q^{\prime}\right\}$ 
2. 对于块的更新和插入, TPAR通过确认 $e\left(\sigma_{k}^{\prime}, g\right) \stackrel{?}{=} e\left(H\left(t_{k}^{\prime}\right) \cdot u^{m_{k}^{\prime}}, v\right)$ 来确定 $\left(t_{k}^{\prime}, m_{k}^{\prime}, \sigma_{k}^{\prime}\right)$ 的正确性, 如果失败了, TPAR会惩罚欺骗的一方,否则, TPAR相信双方都正确更新了块和标签
3. TPAR将 $\left\{s e q_{c}+1, o p, k, t_{k}^{\prime}, m_{k}^{\prime}, \sigma_{k}^{\prime}, Q^{\prime}\right\}$ 发给CSP, 在challenge集合$Q^{\prime}$ 中的请求$\left(\mu^{\prime}, \sigma^{\prime}\right)$ 同样发给CSP, 然后根据**ProofVerify** 来确定u和σ的有效性, 如果失败了, 将会惩罚CSP的延迟更新,否则, TPAR继续执行
4. TPAR将索引切换器更新成$Ω'$ 之后分别向客户端和CSP请求$\operatorname{Sig}_{c}^{\prime}=\operatorname{Sig}_{s k_{c}}(scq_c + 1, Ω')$ 和  $\operatorname{Sig}_{s}^{\prime}=\operatorname{Sig}_{s k_{s}}\left(s e q_{s}+1, \Omega^{\prime}\right)$ , 谁发送了无效的签名就惩罚谁, 如果都有效, TPAR会将$Sig'_c$ 发送给CSP, 把 $Sig'_s$ 发送给客户端

#### 序列号不等($\operatorname{se} q_{c} \neq \operatorname{se} q_{s}$)

1. 如果 $\operatorname{seq}_{c}<\operatorname{seq}_{s}$ , 说明服务器被客户端的重播攻击 欺骗了
2. 如果$\operatorname{se} q_{c}>\operatorname{se} q_{s}+1$ ,说明客户端被服务器的重播攻击欺骗了
3. $s e q_{c}=s e q_{s}+1$ 当CSP接收到客户端的更新请求并拒绝更新并将其签名发送给客户端时，就会发生这种情况。这里有三种可能性。（i）来自客户端的更新记录无效（不一致的块标签对，但在更新的索引切换器上具有有效签名），因此CSP拒绝更新并联系TPAR进行仲裁。（ii）来自客户端的更新记录有效，但是CSP响应时签名无效，因此客户端联系TPAR进行仲裁。（iii）来自客户端的更新记录有效，但是CSP恶意拒绝该更新，因此客户端联系TPAR进行仲裁。

对于延迟更新的情况($seq_c = seq_s + 1$), TPAR很难决定谁应该对更新失败负责,  因为每一方可以对另一方表现出恶意，也可以对TPAR表现出友好 , 例如,  客户可以在当前轮向CSP发送错误的更新记录，并在接下来的仲裁中向TPAR发送正确的更新记录。在这种情况下,TPAR简单运行匹配情况的协议(seqc = seqs)完成更新和签名交换在当前回合,这样双方可以进行进一步的审计或更新 

### 讨论

在我们的仲裁协议中, 每个部分都需要发送签名和最新的数据到另一个部分, 



## 安全性分析

在本节中，我们将通过证明以下两个定理来证明我们的审计方案和仲裁协议的安全性。定理1适应[5]中正确性和健全性的类似定义：（i）如果验证算法在与返回有效响应的有效证明者进行交互时接受，则该方案是正确的。（ii）如果任何欺骗证明者确信验证算法正在存储文件，则该方案是正确的。定理2通过证明所有者和CSP都可以忽略构成协议另一方的可能性，证明了我们仲裁协议的公平性

### 定理1

如果用于块标记和索引切换器的两个签名方案在本质上是不可伪造的，并且很难在双线性群中计算Diffie-Hellman问题，那么，除了通过正确的证据做出回应外，没有任何反对我们方案健全性的对手能够使验证者以不可忽略的概率接受审核协议实例。

### 证明

对于每一个块的标签, 在全局里都是唯一的整形, 不失一般性, 从块索引i到标签索引ti的映射我们可以看成一个单射函数, 所以论文[5]中的对于块索引的hash 查询 跟我们块里的标签索引很相似. 我们现在用[5]中定义的一系列对策来证明随机oracle模型中的定理1 

 Game 0是一个简单的挑战游戏，对手可以在环境中进行存储查询和执行PoS协议 

 游戏1与游戏0相同，不同之处在于挑战者保留了作为PoS协议查询的一部分发出的所有已签名标记的列表 

 游戏2和游戏1是一样的，只是挑战者保留了一个对来自对手的查询的响应列表。 



假设 $Q = (i, v_i)_{i∈I}$ 是一个导致对手赢得游戏的质询, 让$P = {μ, σ, Sig_{sk_s}}(seq, Ω)$ 是一个诚实的证明人应该返回的响应, 满足等式 $e(\sigma, g)=e\left(\left(\prod_{i \in I} H\left(t_{i}\right)^{v_{i}}\right)\right.·u_μ, v)$ , 既然索引切换器$Ω$ 被客户端和CSP都持有, 如果对手给予了一个无效的签名, 验证自然会失败.   因此，伪造证明的索引切换器上的签名应该与预期证明的签名相同。 

**random oracle model** 

A *random oracle* is described by the following model:

- There is a black box. In the box lives a gnome, with a big book and some dice.
- We can input some data into the box (an arbitrary sequence of bits).
- Given some input that he did not see beforehand, the gnome uses his dice to generate a new output, uniformly and randomly, in some conventional space (the space of oracle outputs). The gnome also writes down the input and the newly generated output in his book.
- If given an already seen input, the gnome uses his book to recover the output he returned the last time, and returns it again.

So a random oracle is like a kind of hash function, such that we know nothing about the output we could get for a given input message mm, until we actually try mm. This is a useful tool for security proofs because they allow to express the attack effort in terms of number of invocations to the oracle.



**PoS协议**



### 定理2:

 假设用于签署索引转换器的签名方案是安全的，并且默认的审计方案是安全的，那么仲裁协议提供了安全且公平的仲裁，即客户端和CSP都不能成功地以不可忽略的概率欺骗陷害另一方 

首先我们证明仲裁协议的正确性 $Sig_c(i, Ω)$ 和$Sig_s(i, Ω)$ 表示所以交换器上的客户端和服务器的签名, $Ω_i$表示第i个版本的索引切换器

当客户端上传数据到云端的时候, 在客户端和CSP之间有一个初始化的签名交换, sequencec的序号是0, 并且索引切换器是$Ω_0 = \left\{(i, t_i = i)\right\}_{i<=i<=n}$ ,  此外, 上传的块和标签, CSP必须通过**ProofVerify** 来保证块和标签的一致性, 由于我们的方案是可公开验证的，并且索引切换器的初始内容也是公开的，所以即使是CSP或客户端在这一步的行为不当，也可以通过TPAR进行仲裁，最终可以成功完成初始签名交换。在最初的交流之后， 客户端有了$Sig_s(0,Ω_0)$ CSP有了$Sig_c(0,Ω_0)$ 另一方面, 在每次更新的时候,相关信息也被发送到了CSP,  因此，CSP知道索引切换器的更新，并且可以在每次更新时重新构造它，这使CSP能够检查客户机签名的有效性(在索引切换器上) 



继续更新和签名交换, 假设已经完成两轮以上的, 不是一般性, 客户端偶$Sig_s(0, Ω_0), Sig_s(1,Ω_1),...Sig_s(i,Ω_i)$ 等签名, CSP端也会有对应的签名

现在,我们分析签名交换不能正常完成曾的情况,通常来说, 当客户端 执行下一次更新, 客户端会增加sequence编号,并把索引切换器更新到$Ω_{i+1}$ 并且发送更新记录$\left\{i+1, o p, k, t_{k}^{\prime}, m_{k}^{\prime}\right.\left.\sigma_{k}^{\prime}, Q^{\prime}, \operatorname{Sig}_{c}\left(i+1, \Omega_{i+1}\right)\right\}$到CSP, CSP会回复一个$\left(\mu^{\prime}, \sigma^{\prime}, \operatorname{Sig}_{s}\left(i+1, \Omega_{i+1}\right)\right)$ , 其中 Sigc 依赖于$(i+1, op, k, t'_k)$ 和$Ω$ 的准确性, 在最后一次成功更新的时候, $σ'_k$的准确性依赖于$t'_k$和$m'_k$ 由于两方潜在的不当行为, 这里有五种可能

1. 客户端发送无效的请求, 其中包括不一致的$m_k$ 和$σ_k$ 和无效的签名$Sig_c(i+1, Ω_{i+1})$ 到CSP, CSP当然会拒绝更新并且联系TPAR做更新仲裁, 当 TPAR像两方请求最后一次签名的时候 我们有$seq_c = seq_s=i$ 
2. 客户端发送无效的更新请求(同上)有效的签名$Sig_c(i+1, Ω_{i+1})$到CSP, CSP拒绝更新,联系TPAR做仲裁, TPAR像两方要签名 就会有$seq_c = seq_s + 1$ 
3. 客户端发送一个有效的更新请求到CSP, 但是CSP 返回了一个无效的签名$Sigs(i+1, Ω_{i+1})$ (可能包含不一致的$μ'$和$σ'$ ) 客户端会联系TPAR 做更新仲裁, 在这种情况下, 当TPAR向两边请求最后一次签名的时候, 我们有$seq_c = seq_s + 1$
4. 客户端发送有效的更新请求到CSP, CSP也回复了一个有效的签名$Sigs(i+1, Ω_{i+1})$ 和不一致的的$μ'$和$σ'$ , 客户端联系TPAR做proof仲裁, 在这种情况下, TPAR请求最后一次的签名, 有$seq_c = seq_s$ 
5.  客户端发送有效的更新记录到CSP, 但是CSP拒绝更新, 这种情况和第三种情况很像, 客户端联系TPAR做仲裁, 当TPAR请求最后一次签名, 我们有$seq_c =  seq_s + 1$

根据更新冲裁的协议, 我们可以看到客户端或者CSP在当前回合下的不正当操作, TPAR依旧可以帮助完成第i+1轮的签名交换,在冲裁之后, CSP有签名$Sig_c(i+1, Ω_{i+1})$ 客户端有签名$Sigs(i+1, Ω_{i+1})$ , 这个完成了冲裁协议的proof的正确证明

  其次，证明了仲裁协议的公平性。如果一个恶意的一方想要陷害一个诚实的一方，他必须使用一个比上次成功更新中约定的序列号更大的序列号来伪造诚实一方的有效签名。假设上一轮成功更新中的序列号和索引切换器为 $seq$ 和$Ω$ ,客户端有签名$Sigs(i, Ω_{i})$  CSP 端有签名$Sig_c(i, Ω_{i})$ ,对于客户端来说, 如果想陷害CSP, 则必须伪造一个有效签名$Sig_s(seq', Ω')$ 其中 $seq' > seq$  并且$Ω≠Ω'$  , 对于CSP来说, 如果想陷害客户端, 必须伪造一个有效的签名$Sig_c(seq'', Ω')$ 其中$seq'' > seq +1 $并且 $Ω'' ≠Ω$ ,  这两种情况都与用于签名索引切换器的签名方案的存在性不可伪造性相矛盾。因此，如果恶意方能够以不可忽略的概率伪造这样一个签名，那么他就能够以不可忽略的概率破坏签名方案(用于签名索引切换器)的安全性。这就完成了公平的证明。 

## 性能评估

